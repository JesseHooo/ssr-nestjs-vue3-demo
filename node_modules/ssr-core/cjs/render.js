"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = void 0;
const stream_1 = require("stream");
const ssr_common_utils_1 = require("ssr-common-utils");
const utils_1 = require("./utils");
const defaultConfig = (0, ssr_common_utils_1.loadConfig)();
const sf = (0, ssr_common_utils_1.judgeServerFramework)();
const f = (0, ssr_common_utils_1.judgeFramework)();
const viteServerEntry = (0, ssr_common_utils_1.getViteServerEntry)();
async function render(ctx, options) {
    var _a, _b;
    const mergeConfig = {
        ...defaultConfig,
        ...(((_a = options === null || options === void 0 ? void 0 : options.dynamicFile) === null || _a === void 0 ? void 0 : _a.configFile) ? require(options.dynamicFile.configFile).userConfig : {})
    };
    const config = Object.assign({}, mergeConfig, options);
    // support combine dynamic customeHeadScript when call render
    const { customeHeadScript, customeFooterScript } = mergeConfig;
    config.customeHeadScript = (0, utils_1.getCustomScript)(customeHeadScript, ctx).concat((0, utils_1.getCustomScript)(options === null || options === void 0 ? void 0 : options.customeHeadScript, ctx));
    config.customeFooterScript = (0, utils_1.getCustomScript)(customeFooterScript, ctx).concat((0, utils_1.getCustomScript)(options === null || options === void 0 ? void 0 : options.customeFooterScript, ctx));
    const { isVite, isDev } = config;
    if (!isDev && ((_b = options === null || options === void 0 ? void 0 : options.dynamicFile) === null || _b === void 0 ? void 0 : _b.assetManifest)) {
        config.isVite = !!(require(options.dynamicFile.assetManifest).vite);
    }
    (0, ssr_common_utils_1.setHeader)(ctx, sf);
    const serverRes = isVite ? await viteRender(ctx, config) : await commonRender(ctx, config);
    if (serverRes instanceof stream_1.Stream) {
        if (f !== 'ssr-plugin-react18') {
            const stream = (0, ssr_common_utils_1.mergeStream2)(new ssr_common_utils_1.StringToStream('<!DOCTYPE html>'), serverRes);
            stream.on('error', (e) => {
                console.log(e);
            });
            return stream;
        }
        return serverRes;
    }
    else {
        if (f === 'ssr-plugin-vue3') {
            let { html, teleportsContext } = serverRes;
            if (teleportsContext.teleports) {
                const { teleports } = teleportsContext;
                const cheerio = require('cheerio');
                const $ = cheerio.load(html);
                for (const target in teleports) {
                    const content = teleports[target];
                    $(target).append(content);
                }
                html = $.html();
            }
            return `<!DOCTYPE html>${html}`;
        }
        else {
            return `<!DOCTYPE html>${serverRes}`;
        }
    }
}
exports.render = render;
let viteServer = false;
async function viteRender(ctx, config) {
    const { isDev, dynamicFile } = config;
    let serverRes;
    if (isDev) {
        const { createServer } = await Promise.resolve().then(() => require('vite'));
        const { serverConfig } = await Promise.resolve().then(() => require(f));
        viteServer = !viteServer ? await createServer(serverConfig) : viteServer;
        const { serverRender } = await viteServer.ssrLoadModule(viteServerEntry);
        serverRes = await serverRender(ctx, config);
    }
    else {
        const { serverRender } = require(dynamicFile.serverBundle);
        const serverRes = await serverRender(ctx, config);
        return serverRes;
    }
    return serverRes;
}
async function commonRender(ctx, config) {
    const { isDev, dynamicFile } = config;
    const serverBundle = dynamicFile.serverBundle;
    if (isDev) {
        delete require.cache[serverBundle];
    }
    const { serverRender } = require(dynamicFile.serverBundle);
    const serverRes = await serverRender(ctx, config);
    return serverRes;
}
//# sourceMappingURL=render.js.map