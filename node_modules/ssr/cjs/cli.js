#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployFunc = exports.buildFunc = exports.startFunc = void 0;
const path_1 = require("path");
const child_process_1 = require("child_process");
const yargs = require("yargs");
const html_1 = require("./html");
const clean_1 = require("./clean");
const preprocess_1 = require("./preprocess");
const watcher_1 = require("./watcher");
const ssg_1 = require("./ssg");
const spinnerProcess = (0, child_process_1.fork)((0, path_1.resolve)(__dirname, './spinner')); // 单独创建子进程跑 spinner 否则会被后续的 同步代码 block 导致 loading 暂停
const spinner = {
    start: () => spinnerProcess.send({
        message: 'start'
    }),
    stop: () => spinnerProcess.send({
        message: 'stop'
    })
};
const startOrBuild = async (argv, type) => {
    var _a, _b;
    const { judgeFramework, judgeServerFramework, logGreen } = await Promise.resolve().then(() => require('ssr-common-utils'));
    const framework = judgeFramework();
    const serverFramework = judgeServerFramework();
    if (argv.ssg) {
        logGreen('Using ssg for generate static html file');
    }
    if (!argv.api) {
        const { clientPlugin } = await Promise.resolve().then(() => require(framework));
        const client = clientPlugin();
        await ((_a = client === null || client === void 0 ? void 0 : client[type]) === null || _a === void 0 ? void 0 : _a.call(client, argv));
    }
    if (!argv.web) {
        const { serverPlugin } = await Promise.resolve().then(() => require(serverFramework));
        const server = serverPlugin();
        await ((_b = server === null || server === void 0 ? void 0 : server[type]) === null || _b === void 0 ? void 0 : _b.call(server, argv));
    }
    if (type === 'build') {
        await (0, html_1.generateHtml)();
        await (0, ssg_1.ssg)(argv);
    }
};
const startFunc = async (argv) => {
    if (!argv.vite) {
        spinner.start();
    }
    await (0, clean_1.cleanOutDir)(argv);
    process.env.NODE_ENV = 'development';
    const { parseFeRoutes, transformConfig, logInfo } = await Promise.resolve().then(() => require('ssr-common-utils'));
    await transformConfig();
    if (argv.vite) {
        logInfo('Vite 场景本地开发样式闪烁为正常现象请忽略，生产环境无此问题');
    }
    const watcher = await (0, watcher_1.createWatcher)();
    await (0, preprocess_1.handleEnv)(argv);
    await parseFeRoutes();
    spinner.stop();
    await startOrBuild(argv, 'start');
    await (0, watcher_1.onWatcher)(watcher);
};
exports.startFunc = startFunc;
const buildFunc = async (argv) => {
    spinner.start();
    await (0, clean_1.cleanOutDir)(argv);
    process.env.NODE_ENV = 'production';
    const { parseFeRoutes, transformConfig } = await Promise.resolve().then(() => require('ssr-common-utils'));
    await transformConfig();
    await (0, preprocess_1.handleEnv)(argv);
    await parseFeRoutes();
    spinner.stop();
    await startOrBuild(argv, 'build');
};
exports.buildFunc = buildFunc;
const deployFunc = async (argv) => {
    var _a;
    process.env.NODE_ENV = 'production';
    const { judgeServerFramework } = await Promise.resolve().then(() => require('ssr-common-utils'));
    const serverFramework = judgeServerFramework();
    const { serverPlugin } = await Promise.resolve().then(() => require(serverFramework));
    const server = serverPlugin();
    if (!(server === null || server === void 0 ? void 0 : server.deploy)) {
        console.log('当前插件不支持 deploy 功能，请使用 ssr-plugin-midway 插件 参考 https://www.yuque.com/midwayjs/faas/migrate_egg 或扫码进群了解');
        return;
    }
    await ((_a = server === null || server === void 0 ? void 0 : server.deploy) === null || _a === void 0 ? void 0 : _a.call(server, argv));
    spinner.stop();
};
exports.deployFunc = deployFunc;
const cliDesc = {
    web: {
        desc: 'only start client plugin'
    },
    api: {
        desc: 'only start server plugin'
    }
};
yargs
    .command('start', 'Start Server', yargs => yargs.options({
    bundleConfig: {
        alias: 'bc',
        desc: 'bundle config.ts dependencies module by esbuild'
    },
    vite: {
        desc: 'Start application by vite'
    },
    port: {
        desc: 'Setting application server port, default is 3000'
    },
    optimize: {
        alias: 'o',
        desc: 'Optimize webpack bundle for high performance'
    },
    help: {
        alias: 'h',
        desc: 'In midway, use --help to speed up ts compile'
    },
    nominify: {
        desc: 'Disable minify output file content for debug'
    },
    ...cliDesc
}), async (argv) => {
    if (argv.bc) {
        process.env.BUNDLECONFIG = '1';
    }
    await startFunc(argv);
})
    .command('build', 'Build application by webpack or vite', yargs => yargs.options({
    bundleConfig: {
        alias: 'bc',
        desc: 'bundle config.ts dependencies module by esbuild'
    },
    analyze: {
        alias: 'a',
        desc: 'Analyze bundle result when using webpack for build'
    },
    optimize: {
        alias: 'o',
        desc: 'Optimize webpack bundle for high performance except vue2'
    },
    vite: {
        desc: 'Build application by vite'
    },
    legacy: {
        desc: 'Close default rollup manulChunks setting in vite mode'
    },
    html: {
        desc: 'Build application as a single html'
    },
    ssg: {
        desc: 'Build with Static Site Generation (Pre Render)'
    },
    sourcemap: {
        desc: 'Set type of generate sourcemap by build --sourcemap xxx'
    },
    nominify: {
        desc: 'Disable minify output file content for debug'
    },
    ...cliDesc
}), async (argv) => {
    if (argv.bc) {
        process.env.BUNDLECONFIG = '1';
    }
    const { logWarning } = await Promise.resolve().then(() => require('ssr-common-utils'));
    if (argv.vite) {
        logWarning(`ssr build by vite is beta now, if you find some bugs, please submit an issue on https://github.com/zhangyuang/ssr/issues or you can use ssr build --vite --legacy which will close manualChunks
      to get a stable bundle result but maybe some performance loss
      `);
    }
    await buildFunc(argv);
})
    .command('deploy', 'Deploy function to aliyun cloud or tencent cloud', yargs => yargs.options({
    tencent: {
        desc: 'deploy application to tencent clound'
    }
}), async (argv) => {
    await deployFunc(argv);
})
    .command('update', 'check dependencies version is latest', {}, async (argv) => {
    spinner.start();
    const { update } = await Promise.resolve().then(() => require('./update'));
    await update();
    spinner.stop();
})
    .demandCommand(1, 'You need at least one command before moving on')
    .option('version', {
    alias: 'v',
    default: false,
    desc: 'Show current version'
})
    .fail((msg, err) => {
    if (err) {
        console.log(err);
        spinner.stop();
        process.exit(1);
    }
    console.log(msg);
})
    .parse();
//# sourceMappingURL=cli.js.map