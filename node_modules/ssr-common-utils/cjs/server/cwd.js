"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkModuleExist = exports.getPkgJson = exports.checkContainsRev = exports.cleanOutClientDir = exports.getSplitChunksOptions = exports.getWebpackSplitCache = exports.judgeVersion = exports.judgeServerFramework = exports.stringifyDefine = exports.writeRoutes = exports.transformManualRoutes = exports.loadModuleFromFramework = exports.judgeFramework = exports.accessFileSync = exports.transformConfig = exports.cryptoAsyncChunkName = exports.execPromisify = exports.accessFile = exports.processError = exports.isFaaS = exports.getUserConfig = exports.getPagesDir = exports.getFeDir = exports.getCwd = exports.checkTsConfig = exports.getViteServerEntry = exports.getStaticConfig = exports.debounce = exports.checkRoute = exports.getEnvConfig = exports.esbuildTransform = exports.ssrDebug = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const child_process_1 = require("child_process");
const util_1 = require("util");
const semver_1 = require("semver");
const shelljs_1 = require("shelljs");
const debug_1 = require("debug");
const loadConfig_1 = require("./loadConfig");
exports.ssrDebug = (0, debug_1.default)('ssr');
const getCwd = () => {
    var _a;
    return (0, path_1.resolve)(process.cwd(), (_a = process.env.APP_ROOT) !== null && _a !== void 0 ? _a : '');
};
exports.getCwd = getCwd;
const getFeDir = () => {
    var _a;
    return (0, path_1.resolve)(getCwd(), (_a = process.env.FE_ROOT) !== null && _a !== void 0 ? _a : 'web');
};
exports.getFeDir = getFeDir;
const getPagesDir = () => {
    return (0, path_1.resolve)(getFeDir(), 'pages');
};
exports.getPagesDir = getPagesDir;
const cleanOutClientDir = () => {
    (0, shelljs_1.rm)('-rf', (0, path_1.resolve)(getCwd(), './build/client'));
};
exports.cleanOutClientDir = cleanOutClientDir;
const getPkgJson = () => __non_webpack_require__((0, path_1.resolve)(getCwd(), './package.json'));
exports.getPkgJson = getPkgJson;
const writeRoutes = async (routes, name) => {
    const cwd = getCwd();
    await fs_1.promises.writeFile((0, path_1.resolve)(cwd, `./build/${name !== null && name !== void 0 ? name : 'ssr-declare-routes'}`), routes);
};
exports.writeRoutes = writeRoutes;
const getWebpackSplitCache = () => {
    var _a;
    const { optimize, chunkName } = (0, loadConfig_1.loadConfig)();
    if (optimize) {
        const generateMap = require((0, path_1.resolve)(getCwd(), './build/generateMap.json'));
        const asyncChunkMap = require((0, path_1.resolve)(getCwd(), './build/asyncChunkMap.json'));
        let maxPriority = Object.keys(asyncChunkMap).length + 1;
        const splitPriorityMap = {
            'common-vendor': maxPriority + 2,
            'layout-app~vendor': maxPriority + 1,
            'layout-app': maxPriority + 1
        };
        // make priority consistent
        Object.keys(asyncChunkMap).sort((a, b) => {
            const lenA = asyncChunkMap[a];
            const lenB = asyncChunkMap[b];
            if (lenA !== lenB) {
                return asyncChunkMap[b].length - asyncChunkMap[a].length;
            }
            else {
                return a > b ? 1 : -1;
            }
        }).forEach(chunkName => {
            if (!splitPriorityMap[chunkName]) {
                splitPriorityMap[chunkName] = maxPriority - 1;
            }
            maxPriority--;
        });
        const webpackMap = {};
        for (const fileName in generateMap) {
            const chunkName = generateMap[fileName];
            if (!webpackMap[chunkName]) {
                webpackMap[chunkName] = [];
            }
            webpackMap[chunkName].push(fileName);
        }
        delete webpackMap[chunkName];
        const cacheGroups = {};
        for (const chunkName in webpackMap) {
            const arr = webpackMap[chunkName];
            if (!cacheGroups[chunkName]) {
                cacheGroups[chunkName] = {
                    name: chunkName,
                    test: (module) => {
                        var _a;
                        if (chunkName === 'void' || !((_a = module.nameForCondition) === null || _a === void 0 ? void 0 : _a.call(module)))
                            return;
                        const nameForCondition = module.nameForCondition();
                        return checkContains(arr, nameForCondition);
                    },
                    priority: (_a = splitPriorityMap[chunkName]) !== null && _a !== void 0 ? _a : 0
                };
            }
        }
        return cacheGroups;
    }
    else {
        return {
            vendors: {
                test: (module) => {
                    return module.resource &&
                        /\.js$/.test(module.resource) &&
                        module.resource.match('node_modules');
                },
                name: 'vendor'
            }
        };
    }
};
exports.getWebpackSplitCache = getWebpackSplitCache;
const checkContains = (arr, name) => {
    for (const val of arr) {
        if (val.includes(name)) {
            return true;
        }
    }
    return false;
};
const checkContainsRev = (arr, name) => {
    for (const val of arr) {
        if (name.includes(val)) {
            return true;
        }
    }
    return false;
};
exports.checkContainsRev = checkContainsRev;
const getSplitChunksOptions = (asyncChunkMap) => {
    const { optimize } = (0, loadConfig_1.loadConfig)();
    return {
        minSize: optimize ? 0 : 2000,
        maxAsyncRequests: 5,
        maxInitialRequests: 3,
        chunks: 'all',
        name(module, chunks, cacheGroupKey) {
            return cryptoAsyncChunkName(chunks, asyncChunkMap.val);
        },
        cacheGroups: getWebpackSplitCache()
    };
};
exports.getSplitChunksOptions = getSplitChunksOptions;
const transformConfig = async () => {
    // serverless 发布无需安装 shelljs esbuild, 提前本地 build 好
    const { cp } = await Promise.resolve().then(() => require('shelljs'));
    const cwd = getCwd();
    if (await accessFile((0, path_1.resolve)(cwd, './config.js'))) {
        cp('-r', `${(0, path_1.resolve)(cwd, './config.js')}`, `${(0, path_1.resolve)(cwd, './build/config.js')}`);
    }
    else {
        await (0, exports.esbuildTransform)((0, path_1.resolve)(cwd, './config.ts'), (0, path_1.resolve)(cwd, './build/config.js'));
    }
};
exports.transformConfig = transformConfig;
const esbuildTransform = async (from, to) => {
    if (!await accessFile(from)) {
        await fs_1.promises.writeFile(from, '');
    }
    const { build } = await Promise.resolve().then(() => require('esbuild'));
    await build({
        entryPoints: [from],
        keepNames: true,
        format: 'cjs',
        bundle: !!process.env.BUNDLECONFIG,
        outfile: to,
        platform: 'node',
        mainFields: ['module', 'main'],
        treeShaking: true
    });
};
exports.esbuildTransform = esbuildTransform;
const transformManualRoutes = async () => {
    const cwd = getCwd();
    const declaretiveRoutes = await accessFile((0, path_1.resolve)(getFeDir(), './route.ts')); // 是否存在自定义路由
    if (!declaretiveRoutes) {
        await fs_1.promises.writeFile((0, path_1.resolve)(cwd, './build/ssr-manual-routes.js'), '');
        return;
    }
    const { transform } = await Promise.resolve().then(() => require('esbuild'));
    const fileContent = (await fs_1.promises.readFile((0, path_1.resolve)(getFeDir(), './route.ts'))).toString();
    const { code } = await transform(fileContent, {
        loader: 'ts',
        format: 'esm',
        keepNames: true
    });
    const serializeCode = code.replace(/(import\([\s\S]*?\))/g, (match) => {
        return match.replace(/\s/g, '');
    });
    await fs_1.promises.writeFile((0, path_1.resolve)(cwd, './build/ssr-manual-routes.js'), serializeCode);
};
exports.transformManualRoutes = transformManualRoutes;
const getUserConfig = () => {
    var _a;
    const defaultConfig = (0, path_1.resolve)(getCwd(), './build/config.js');
    const userConfig = accessFileSync(defaultConfig) ? ((_a = __non_webpack_require__(defaultConfig).userConfig) !== null && _a !== void 0 ? _a : __non_webpack_require__(defaultConfig)) : {}; // for dynamic file
    return Object.assign(userConfig, (0, exports.getEnvConfig)());
};
exports.getUserConfig = getUserConfig;
const getEnvConfig = () => {
    return process.env.ssrConfig ? JSON.parse(process.env.ssrConfig) : {};
};
exports.getEnvConfig = getEnvConfig;
const cyrb53 = function (str, seed = 0) {
    let h1 = 0xdeadbeef ^ seed;
    let h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
const cryptoAsyncChunkName = (chunks, asyncChunkMap) => {
    const arr = chunks.filter(Boolean);
    arr.sort((a, b) => a.name > b.name ? -1 : 1); // 保证相同值不同顺序的数组最终的加密结果一致
    const allChunksNames = arr.map(item => item.name).join('~');
    const allChunksNamesArr = allChunksNames.split('~');
    const cryptoAllChunksNames = String(arr.length > 3 ? cyrb53(allChunksNames) : allChunksNames);
    if (allChunksNamesArr.length >= 2 && !(asyncChunkMap === null || asyncChunkMap === void 0 ? void 0 : asyncChunkMap[cryptoAllChunksNames])) {
        asyncChunkMap[cryptoAllChunksNames] = allChunksNamesArr;
    }
    return cryptoAllChunksNames;
};
exports.cryptoAsyncChunkName = cryptoAsyncChunkName;
const isFaaS = async (fun) => {
    const result = await fs_1.promises.access((0, path_1.resolve)(getCwd(), fun ? 'template.yml' : 'f.yml'))
        .then(() => true)
        .catch(() => false);
    return result;
};
exports.isFaaS = isFaaS;
const checkRoute = ({ routeItem, path }) => {
    if (!(routeItem === null || routeItem === void 0 ? void 0 : routeItem.path)) {
        throw new Error(`
      With Path: ${path} search component failed
      If you create new folder or component file, please restart server by npm start
      `);
    }
};
exports.checkRoute = checkRoute;
const judgeFramework = () => {
    const { framework } = getUserConfig();
    if (framework) {
        return framework;
    }
    const cwd = getCwd();
    const packageJSON = require((0, path_1.resolve)(cwd, './package.json'));
    if (packageJSON.dependencies.react || packageJSON.devDependencies.react) {
        const version = packageJSON.dependencies.react || packageJSON.devDependencies.react;
        return (0, semver_1.coerce)(version).major === 18 ? 'ssr-plugin-react18' : 'ssr-plugin-react';
    }
    else if (packageJSON.dependencies.vue || packageJSON.devDependencies.vue) {
        const version = packageJSON.dependencies.vue || packageJSON.devDependencies.vue;
        return (0, semver_1.coerce)(version).major === 3 ? 'ssr-plugin-vue3' : 'ssr-plugin-vue';
    }
    else {
        throw new Error('get framework failed, please check dependencies');
    }
};
exports.judgeFramework = judgeFramework;
const judgeVersion = (version) => {
    return (0, semver_1.coerce)(version);
};
exports.judgeVersion = judgeVersion;
const judgeServerFramework = () => {
    const cwd = getCwd();
    const packageJSON = require((0, path_1.resolve)(cwd, './package.json'));
    if (packageJSON.dependencies['@midwayjs/decorator']) {
        return 'ssr-plugin-midway';
    }
    else {
        return 'ssr-plugin-nestjs';
    }
};
exports.judgeServerFramework = judgeServerFramework;
const debounce = (func, wait) => {
    let timer;
    return () => {
        clearTimeout(timer);
        timer = setTimeout(func, wait);
    };
};
exports.debounce = debounce;
const checkModuleExist = (name) => {
    try {
        loadModuleFromFramework(name);
        return true;
    }
    catch (_a) {
        return false;
    }
};
exports.checkModuleExist = checkModuleExist;
const loadModuleFromFramework = (path) => {
    const framework = judgeFramework();
    const paths = (0, path_1.resolve)(getCwd(), `./node_modules/${framework}`);
    return require.resolve(path, {
        paths: [accessFileSync(paths) ? (0, fs_1.realpathSync)(paths) : paths]
    });
};
exports.loadModuleFromFramework = loadModuleFromFramework;
const processError = (err) => {
    if (err) {
        console.log(err);
        process.exit(1);
    }
};
exports.processError = processError;
const accessFile = async (file) => {
    const result = await fs_1.promises.access(file)
        .then(() => true)
        .catch(() => false);
    return result;
};
exports.accessFile = accessFile;
const accessFileSync = (file) => {
    let res = true;
    try {
        (0, fs_1.accessSync)(file);
    }
    catch (error) {
        res = false;
    }
    return res;
};
exports.accessFileSync = accessFileSync;
const getStaticConfig = () => {
    const staticConfigPath = (0, path_1.resolve)(getCwd(), './build/staticConfig.js');
    const staticConfig = accessFileSync(staticConfigPath) ? __non_webpack_require__(staticConfigPath) : {};
    return staticConfig;
};
exports.getStaticConfig = getStaticConfig;
const execPromisify = (0, util_1.promisify)(child_process_1.exec);
exports.execPromisify = execPromisify;
const stringifyDefine = (obj) => {
    for (const key in obj) {
        const val = obj[key];
        if (typeof val === 'string' && val.slice(0, 1) !== '"') {
            obj[key] = JSON.stringify(val);
        }
        else if (typeof val === 'object') {
            stringifyDefine(val);
        }
    }
};
exports.stringifyDefine = stringifyDefine;
const getViteServerEntry = () => {
    const cwd = getCwd();
    const framework = judgeFramework();
    return (0, path_1.resolve)(cwd, `./node_modules/${framework}/esm/entry/server-entry.js`);
};
exports.getViteServerEntry = getViteServerEntry;
const checkTsConfig = async () => {
    const cwd = getCwd();
    const { logWarning } = await Promise.resolve().then(() => require('./log'));
    const f = judgeServerFramework();
    if (f !== 'ssr-plugin-midway')
        return;
    const tsconfigExist = await accessFile((0, path_1.resolve)(cwd, './tsconfig.json'));
    if (tsconfigExist) {
        try {
            const paths = require((0, path_1.resolve)(cwd, './tsconfig.json')).compilerOptions.paths;
            if (paths) {
                logWarning('在 Midway 中不建议使用 tsconfig paths 去引用非类型文件, ref https://midwayjs.org/docs/faq/alias_path');
            }
        }
        catch (error) {
            // 有可能 json 文件存在注释导致 require 失败，这里 catch 一下
            console.log('检测到当前目录 tsconfig.json 文件可能存在语法错误，请检查是否存在注释或多余的符号');
        }
    }
};
exports.checkTsConfig = checkTsConfig;
//# sourceMappingURL=cwd.js.map