"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInlineCss = exports.getScriptArr = exports.getUserScriptVue = exports.getAsyncJsChunk = exports.getAsyncCssChunk = exports.getDefineEnv = exports.nomalrizeOrder = exports.splitPageInfo = exports.setHeader = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const qs_1 = require("qs");
const cwd_1 = require("./cwd");
const setHeader = (ctx, serverFrameWork) => {
    if (serverFrameWork === 'ssr-plugin-midway') {
        ctx.response.type = 'text/html;charset=utf-8';
    }
    else if (serverFrameWork === 'ssr-plugin-nestjs') {
        if (ctx.response.setHeader) {
            // for express
            if (!ctx.response.headersSent) {
                ctx.response.setHeader('Content-type', 'text/html;charset=utf-8');
            }
        }
        else if (!ctx.response.raw.headersSent) {
            // for fastify
            ctx.response.header('Content-type', 'text/html;charset=utf-8');
        }
    }
};
exports.setHeader = setHeader;
const splitPageInfo = (info) => (0, qs_1.stringify)(info, {
    encode: false,
    delimiter: ';'
});
exports.splitPageInfo = splitPageInfo;
const readAsyncChunk = async (config) => {
    try {
        const { dynamicFile } = config;
        const str = (await fs_1.promises.readFile(dynamicFile === null || dynamicFile === void 0 ? void 0 : dynamicFile.asyncChunkMap)).toString();
        return JSON.parse(str);
    }
    catch (error) {
        return {};
    }
};
const addAsyncChunk = async (webpackChunkName, config, type) => {
    const arr = [];
    const asyncChunkMap = await readAsyncChunk(config);
    for (const key in asyncChunkMap) {
        if (asyncChunkMap[key].includes(webpackChunkName) || asyncChunkMap[key].includes('client-entry')) {
            arr.push(`${key}.${type}`);
        }
    }
    return arr;
};
const nomalrizeOrder = (order, ctx) => {
    if (!order) {
        return [];
    }
    if (Array.isArray(order)) {
        return order;
    }
    else {
        return order(ctx);
    }
};
exports.nomalrizeOrder = nomalrizeOrder;
const envVarRegex = /^[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*$/;
const getDefineEnv = () => {
    const envObject = {};
    Object.keys(process.env).forEach(key => {
        if (envVarRegex.test(key)) {
            envObject[`process.env.${key}`] = process.env[key];
        }
    });
    (0, cwd_1.stringifyDefine)(envObject);
    return envObject;
};
exports.getDefineEnv = getDefineEnv;
const getAsyncCssChunk = async (ctx, webpackChunkName, config) => {
    const { cssOrder, extraCssOrder, cssOrderPriority } = config;
    const combineOrder = cssOrder.concat([...(0, exports.nomalrizeOrder)(extraCssOrder, ctx), ...await addAsyncChunk(webpackChunkName, config, 'css'), `${webpackChunkName}.css`]);
    if (cssOrderPriority) {
        const priority = typeof cssOrderPriority === 'function' ? cssOrderPriority({ chunkName: webpackChunkName }) : cssOrderPriority;
        combineOrder.sort((a, b) => {
            // 没有显示指定的路由优先级统一为 0
            return (priority[b] || 0) - (priority[a] || 0);
        });
    }
    return combineOrder;
};
exports.getAsyncCssChunk = getAsyncCssChunk;
const getAsyncJsChunk = async (ctx, webpackChunkName, config) => {
    const { jsOrder, extraJsOrder, jsOrderPriority } = config;
    const combineOrder = jsOrder.concat([...(0, exports.nomalrizeOrder)(extraJsOrder, ctx), ...await addAsyncChunk(webpackChunkName, config, 'js')]);
    if (jsOrderPriority) {
        const priority = typeof jsOrderPriority === 'function' ? jsOrderPriority({ chunkName: webpackChunkName }) : jsOrderPriority;
        combineOrder.sort((a, b) => {
            // 没有显示指定的路由优先级统一为 0
            return (priority[b] || 0) - (priority[a] || 0);
        });
    }
    return combineOrder;
};
exports.getAsyncJsChunk = getAsyncJsChunk;
const getUserScriptVue = (options) => {
    const { script, ctx, position, staticConfig } = options;
    const defaultScriptArr = (0, exports.getScriptArr)(script, ctx);
    const staticScript = position === 'header' ? staticConfig.customeHeadScript : staticConfig.customeFooterScript;
    const staticScriptArr = (0, exports.getScriptArr)(staticScript, ctx);
    return defaultScriptArr.concat(staticScriptArr);
};
exports.getUserScriptVue = getUserScriptVue;
const getScriptArr = (script, ctx) => {
    var _a;
    return Array.isArray(script) ? script : ((_a = script === null || script === void 0 ? void 0 : script(ctx)) !== null && _a !== void 0 ? _a : []);
};
exports.getScriptArr = getScriptArr;
const getInlineCss = async ({ dynamicCssOrder, manifest, config, type }) => {
    const { cssInline } = config;
    const cwd = (0, cwd_1.getCwd)();
    const { cssInlineOrder, cssInjectOrder } = cssInline === 'all' ? {
        cssInlineOrder: dynamicCssOrder,
        cssInjectOrder: []
    } : dynamicCssOrder.reduce((pre, curr) => ({
        cssInlineOrder: (cssInline === null || cssInline === void 0 ? void 0 : cssInline.includes(curr)) ? [...pre.cssInlineOrder, curr] : pre.cssInlineOrder,
        cssInjectOrder: !(cssInline === null || cssInline === void 0 ? void 0 : cssInline.includes(curr)) ? [...pre.cssInjectOrder, curr] : pre.cssInjectOrder
    }), { cssInlineOrder: [], cssInjectOrder: [] });
    const inlineCssContent = (await Promise.all(cssInlineOrder.map(css => manifest[css]).filter(Boolean).map(css => fs_1.promises.readFile((0, path_1.isAbsolute)(css) ? css : (0, path_1.join)(cwd, './build', css))))).map(item => item.toString());
    return [
        inlineCssContent,
        cssInjectOrder
    ];
};
exports.getInlineCss = getInlineCss;
//# sourceMappingURL=runtime.js.map