import { promises } from 'fs';
import { EventEmitter } from 'events';
import { resolve, isAbsolute } from 'path';
import { parse as parseImports } from 'es-module-lexer';
import MagicString from 'magic-string';
import { mkdir } from 'shelljs';
import { loadConfig } from '../loadConfig';
import { getOutputPublicPath } from '../parse';
import { getCwd, cryptoAsyncChunkName, accessFile, debounce, ssrDebug } from '../cwd';
import { logErr } from '../log';
import { getDependencies, getPkgName } from '../build-utils';
import { getBuildConfig } from '../build-config';
import { defaultExternal } from '../static';
const webpackCommentRegExp = /webpackChunkName:\s?"(.*)?"\s?\*/;
const chunkNameRe = /chunkName=(.*)/;
const imageRegExp = /\.(jpe?g|png|svg|gif)(\?[a-z0-9=.]+)?$/;
const fontRegExp = /\.(eot|woff|woff2|ttf)(\?.*)?$/;
const cwd = getCwd();
const dependenciesMap = {};
const asyncChunkMapJSON = {};
const generateMap = {};
const vendorList = ['vue', 'vuex', 'vue-demi', 'vue-router', 'react', 'react-router',
    'react-router-dom', 'react-dom', '@vue', 'ssr-hoc-react', 'ssr-hoc-react18',
    'ssr-client-utils', 'ssr-common-utils', 'pinia', '@babel/runtime',
    'ssr-plugin-vue3', 'ssr-plugin-vue', 'ssr-plugin-react', 'react/jsx-runtime',
    'path-to-regexp', 'plugin-vue:export-helper', '@vue/devtools-api', 'ssr-hoc-vue3', 'ssr-hoc-vue'
];
const chunkNamePlugin = function () {
    return {
        name: 'chunkNamePlugin',
        transform(source, id) {
            var _a;
            if (id.includes('ssr-declare-routes') || id.includes('ssr-manual-routes')) {
                let str = new MagicString(source);
                const imports = parseImports(source)[0];
                for (let index = 0; index < imports.length; index++) {
                    const { s: start, e: end, se: statementEnd } = imports[index];
                    const rawUrl = source.slice(start, end);
                    const chunkName = (_a = webpackCommentRegExp.exec(rawUrl)) === null || _a === void 0 ? void 0 : _a[1];
                    if (!rawUrl.includes('render')) {
                        if (rawUrl.includes('layout') || rawUrl.includes('App') || rawUrl.includes('store')) {
                            str = str.appendRight(statementEnd - 1, '?chunkName=Page');
                        }
                        else if (chunkName) {
                            str = str.appendRight(statementEnd - 1, `?chunkName=${chunkName}`);
                        }
                        else {
                            str = str.appendRight(statementEnd - 1, '?chunkName=Page');
                        }
                        continue;
                    }
                    str = str.appendRight(statementEnd - 1, `?chunkName=${chunkName}`);
                }
                return {
                    code: str.toString()
                };
            }
        }
    };
};
const filePathMap = {};
const recordInfo = (id, chunkName, defaultChunkName, parentId) => {
    const sign = id.includes('node_modules') ? getPkgName(id) : id;
    if (id.includes('node_modules')) {
        filePathMap[sign] = parentId;
    }
    if (!dependenciesMap[sign]) {
        dependenciesMap[sign] = defaultChunkName ? [defaultChunkName] : [];
    }
    chunkName && dependenciesMap[sign].push(chunkName);
    if (id.includes('node_modules')) {
        dependenciesMap[sign].push('vendor');
    }
    if (parentId) {
        dependenciesMap[sign] = dependenciesMap[sign].concat(dependenciesMap[parentId]);
    }
    dependenciesMap[sign] = Array.from(new Set(dependenciesMap[sign].filter(Boolean))).sort(sortByAscii);
};
const sortByAscii = (a, b) => {
    for (let i = 0; i < Math.min(a.length, b.length); i++) {
        if (a.charCodeAt(i) !== b.charCodeAt(i)) {
            return a.charCodeAt(i) - b.charCodeAt(i);
        }
    }
    return a.length - b.length;
};
let hasWritten = false;
const writeEmitter = new EventEmitter();
const fn = () => {
    const { writeDebounceTime } = loadConfig();
    return debounce(() => {
        if (hasWritten) {
            throw new Error(`generateMap has been written over twice, please check your machine performance, or add config.writeDebounceTime that default is ${writeDebounceTime}ms`);
        }
        hasWritten = true;
        writeEmitter.emit('buildEnd');
    }, writeDebounceTime);
};
let checkBuildEnd;
const moduleIds = [];
const findChildren = (id, getModuleInfo) => {
    var _a;
    const queue = [id];
    while (queue.length > 0) {
        const id = queue.shift();
        if (id === null || id === void 0 ? void 0 : id.includes('node_modules')) {
            continue;
        }
        const { importedIds = [], dynamicallyImportedIds = [] } = (_a = getModuleInfo(id)) !== null && _a !== void 0 ? _a : {};
        for (const importerId of importedIds) {
            recordInfo(importerId, null, null, id);
            queue.push(importerId);
        }
        for (const dyImporterId of dynamicallyImportedIds) {
            recordInfo(dyImporterId, null, 'dynamic', id);
            queue.push(dyImporterId);
        }
    }
};
const asyncOptimizeChunkPlugin = () => {
    return {
        name: 'asyncOptimizeChunkPlugin',
        moduleParsed(info) {
            const { id } = info;
            if (id.includes('chunkName')) {
                const { importedIds, dynamicallyImportedIds } = info;
                const chunkName = id.includes('client-entry') ? 'client-entry' : chunkNameRe.exec(id)[1];
                for (const importerId of importedIds) {
                    recordInfo(importerId, chunkName, null, id);
                }
                for (const dyImporterId of dynamicallyImportedIds) {
                    recordInfo(dyImporterId, chunkName, 'dynamic', id);
                }
            }
        },
        buildStart() {
            checkBuildEnd = fn();
        },
        transform(code, id) {
            moduleIds.push(id);
            ssrDebug(`build optimize process file ${id}`);
            checkBuildEnd();
        },
        async buildEnd(err) {
            // after the first layer file can be located in which chunkName
            // confirm all children dependence belong to which chunkName
            Object.keys(dependenciesMap).forEach(item => {
                const id = !isAbsolute(item) ? filePathMap[item] : item;
                findChildren(id, this.getModuleInfo);
            });
            Object.keys(dependenciesMap).forEach(item => {
                if (!isAbsolute(item)) {
                    const abPath = filePathMap[item];
                    if (abPath) {
                        try {
                            const allDependencies = {};
                            // find absolute dependencies path from business file
                            getDependencies(require.resolve(item, {
                                paths: [abPath]
                            }), allDependencies);
                            Object.keys(allDependencies).forEach(d => {
                                var _a;
                                dependenciesMap[d] = ((_a = dependenciesMap[d]) !== null && _a !== void 0 ? _a : []).concat(dependenciesMap[item]);
                            });
                        }
                        catch (error) {
                            logErr(`Please check ${getPkgName(abPath)}/package.json ${abPath} use ${item} but don't specify it in dependencies`);
                        }
                    }
                }
            });
            Object.keys(dependenciesMap).forEach(item => {
                dependenciesMap[item] = Array.from(new Set(dependenciesMap[item].filter(Boolean)));
            });
            return await new Promise((resolve) => {
                if (err) {
                    logErr(JSON.stringify(err));
                    writeEmitter.on('buildEnd', () => {
                        for (const id of moduleIds) {
                            setGenerateMap(id);
                        }
                        writeEmitter.removeAllListeners();
                        writeGenerateMap().then(() => resolve());
                    });
                }
                else {
                    for (const id of moduleIds) {
                        setGenerateMap(id);
                    }
                    writeGenerateMap().then(() => resolve());
                }
            });
        }
    };
};
const manifestPlugin = () => {
    const { getOutput, optimize } = loadConfig();
    const { clientOutPut } = getOutput();
    return {
        name: 'manifestPlugin',
        async generateBundle(_, bundles) {
            if (optimize)
                return;
            const manifest = {};
            for (const bundle in bundles) {
                const val = bundle;
                const arr = bundle.split('/')[1].split('.');
                arr.splice(1, 2);
                manifest[arr.join('.')] = `${getOutputPublicPath()}${val}`;
            }
            if (!await accessFile(resolve(clientOutPut))) {
                mkdir('-p', resolve(clientOutPut));
            }
            manifest['vite'] = '1';
            await promises.writeFile(resolve(clientOutPut, './asset-manifest.json'), JSON.stringify(manifest, null, 2));
        }
    };
};
const writeGenerateMap = async () => {
    await promises.writeFile(resolve(getCwd(), './build/asyncChunkMap.json'), JSON.stringify(asyncChunkMapJSON, null, 2));
    await promises.writeFile(resolve(getCwd(), './build/generateMap.json'), JSON.stringify(generateMap, null, 2));
    await promises.writeFile(resolve(getCwd(), './build/dependenciesMap.json'), JSON.stringify(dependenciesMap, null, 2));
};
const setGenerateMap = (id) => {
    const res = manualChunksFn(id);
    generateMap[id] = res !== null && res !== void 0 ? res : 'Page';
};
const rollupOutputOptions = () => {
    const buildConfig = getBuildConfig();
    return {
        entryFileNames: (chunkInfo) => {
            return buildConfig.viteEntryChunk;
        },
        chunkFileNames: buildConfig.jsBuldConfig.chunkFileName,
        assetFileNames: (assetInfo) => {
            var _a;
            if ((_a = assetInfo.name) === null || _a === void 0 ? void 0 : _a.includes('client-entry')) {
                return buildConfig.viteClientEntryChunk;
            }
            if (assetInfo.name && (imageRegExp.test(assetInfo.name) || fontRegExp.test(assetInfo.name))) {
                return buildConfig.viteImageChunk;
            }
            return buildConfig.viteAssetChunk;
        },
        manualChunks: (id) => {
            return generateMap[id];
        }
    };
};
const manualChunksFn = (id) => {
    var _a;
    if (id.includes('chunkName')) {
        const chunkName = chunkNameRe.exec(id)[1];
        return chunkName;
    }
    if (!process.env.LEGACY_VITE) {
        const sign = id.includes('node_modules') ? getPkgName(id) : id;
        if (vendorList.includes(sign)) {
            // build in Page chunk
            return 'Page';
        }
        const arr = (_a = dependenciesMap[sign]) !== null && _a !== void 0 ? _a : [];
        if (arr.length === 1) {
            return arr[0];
        }
        else if (arr.length >= 2) {
            if (arr.includes('Page')) {
                return 'Page';
            }
            const commonChunkName = cryptoAsyncChunkName(arr.map(item => ({ name: item })), asyncChunkMapJSON);
            return commonChunkName === 'vendor~client-entry' ? 'common-vendor' : commonChunkName;
        }
    }
};
const commonConfig = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const { whiteList, alias, css, hmr, viteConfig, optimize } = loadConfig();
    const lessOptions = ((_b = (_a = css === null || css === void 0 ? void 0 : css().loaderOptions) === null || _a === void 0 ? void 0 : _a.less) === null || _b === void 0 ? void 0 : _b.lessOptions) ? (_d = (_c = css === null || css === void 0 ? void 0 : css().loaderOptions) === null || _c === void 0 ? void 0 : _c.less) === null || _d === void 0 ? void 0 : _d.lessOptions : (_e = css === null || css === void 0 ? void 0 : css().loaderOptions) === null || _e === void 0 ? void 0 : _e.less;
    return {
        root: cwd,
        mode: 'development',
        ...(optimize ? { logLevel: 'slient' } : {}),
        server: {
            middlewareMode: 'ssr',
            hmr,
            ...(_f = viteConfig === null || viteConfig === void 0 ? void 0 : viteConfig().common) === null || _f === void 0 ? void 0 : _f.server
        },
        css: {
            postcss: (_h = (_g = css === null || css === void 0 ? void 0 : css().loaderOptions) === null || _g === void 0 ? void 0 : _g.postcss) !== null && _h !== void 0 ? _h : {},
            preprocessorOptions: {
                less: {
                    javascriptEnabled: true,
                    ...lessOptions
                },
                scss: (_k = (_j = css === null || css === void 0 ? void 0 : css().loaderOptions) === null || _j === void 0 ? void 0 : _j.scss) !== null && _k !== void 0 ? _k : {}
            }
        },
        // @ts-expect-error
        ssr: {
            external: defaultExternal.concat((_o = (_m = (_l = viteConfig === null || viteConfig === void 0 ? void 0 : viteConfig()) === null || _l === void 0 ? void 0 : _l.server) === null || _m === void 0 ? void 0 : _m.externals) !== null && _o !== void 0 ? _o : []),
            noExternal: whiteList
        },
        resolve: {
            alias: alias,
            extensions: ['.mjs', '.ts', '.jsx', '.tsx', '.json', '.vue', '.js']
        }
    };
};
export { chunkNamePlugin, manifestPlugin, rollupOutputOptions, commonConfig, asyncOptimizeChunkPlugin, writeEmitter };
//# sourceMappingURL=config-plugin.js.map