import { promises } from 'fs';
import { join, isAbsolute } from 'path';
import { stringify } from 'qs';
import { getCwd, stringifyDefine } from './cwd';
export const setHeader = (ctx, serverFrameWork) => {
    if (serverFrameWork === 'ssr-plugin-midway') {
        ctx.response.type = 'text/html;charset=utf-8';
    }
    else if (serverFrameWork === 'ssr-plugin-nestjs') {
        if (ctx.response.setHeader) {
            // for express
            if (!ctx.response.headersSent) {
                ctx.response.setHeader('Content-type', 'text/html;charset=utf-8');
            }
        }
        else if (!ctx.response.raw.headersSent) {
            // for fastify
            ctx.response.header('Content-type', 'text/html;charset=utf-8');
        }
    }
};
export const splitPageInfo = (info) => stringify(info, {
    encode: false,
    delimiter: ';'
});
const readAsyncChunk = async (config) => {
    try {
        const { dynamicFile } = config;
        const str = (await promises.readFile(dynamicFile === null || dynamicFile === void 0 ? void 0 : dynamicFile.asyncChunkMap)).toString();
        return JSON.parse(str);
    }
    catch (error) {
        return {};
    }
};
const addAsyncChunk = async (webpackChunkName, config, type) => {
    const arr = [];
    const asyncChunkMap = await readAsyncChunk(config);
    for (const key in asyncChunkMap) {
        if (asyncChunkMap[key].includes(webpackChunkName) || asyncChunkMap[key].includes('client-entry')) {
            arr.push(`${key}.${type}`);
        }
    }
    return arr;
};
export const nomalrizeOrder = (order, ctx) => {
    if (!order) {
        return [];
    }
    if (Array.isArray(order)) {
        return order;
    }
    else {
        return order(ctx);
    }
};
const envVarRegex = /^[a-zA-Z_][a-zA-Z0-9_]*(\.[a-zA-Z_][a-zA-Z0-9_]*)*$/;
export const getDefineEnv = () => {
    const envObject = {};
    Object.keys(process.env).forEach(key => {
        if (envVarRegex.test(key)) {
            envObject[`process.env.${key}`] = process.env[key];
        }
    });
    stringifyDefine(envObject);
    return envObject;
};
export const getAsyncCssChunk = async (ctx, webpackChunkName, config) => {
    const { cssOrder, extraCssOrder, cssOrderPriority } = config;
    const combineOrder = cssOrder.concat([...nomalrizeOrder(extraCssOrder, ctx), ...await addAsyncChunk(webpackChunkName, config, 'css'), `${webpackChunkName}.css`]);
    if (cssOrderPriority) {
        const priority = typeof cssOrderPriority === 'function' ? cssOrderPriority({ chunkName: webpackChunkName }) : cssOrderPriority;
        combineOrder.sort((a, b) => {
            // 没有显示指定的路由优先级统一为 0
            return (priority[b] || 0) - (priority[a] || 0);
        });
    }
    return combineOrder;
};
export const getAsyncJsChunk = async (ctx, webpackChunkName, config) => {
    const { jsOrder, extraJsOrder, jsOrderPriority } = config;
    const combineOrder = jsOrder.concat([...nomalrizeOrder(extraJsOrder, ctx), ...await addAsyncChunk(webpackChunkName, config, 'js')]);
    if (jsOrderPriority) {
        const priority = typeof jsOrderPriority === 'function' ? jsOrderPriority({ chunkName: webpackChunkName }) : jsOrderPriority;
        combineOrder.sort((a, b) => {
            // 没有显示指定的路由优先级统一为 0
            return (priority[b] || 0) - (priority[a] || 0);
        });
    }
    return combineOrder;
};
export const getUserScriptVue = (options) => {
    const { script, ctx, position, staticConfig } = options;
    const defaultScriptArr = getScriptArr(script, ctx);
    const staticScript = position === 'header' ? staticConfig.customeHeadScript : staticConfig.customeFooterScript;
    const staticScriptArr = getScriptArr(staticScript, ctx);
    return defaultScriptArr.concat(staticScriptArr);
};
export const getScriptArr = (script, ctx) => {
    var _a;
    return Array.isArray(script) ? script : ((_a = script === null || script === void 0 ? void 0 : script(ctx)) !== null && _a !== void 0 ? _a : []);
};
export const getInlineCss = async ({ dynamicCssOrder, manifest, config, type }) => {
    const { cssInline } = config;
    const cwd = getCwd();
    const { cssInlineOrder, cssInjectOrder } = cssInline === 'all' ? {
        cssInlineOrder: dynamicCssOrder,
        cssInjectOrder: []
    } : dynamicCssOrder.reduce((pre, curr) => ({
        cssInlineOrder: (cssInline === null || cssInline === void 0 ? void 0 : cssInline.includes(curr)) ? [...pre.cssInlineOrder, curr] : pre.cssInlineOrder,
        cssInjectOrder: !(cssInline === null || cssInline === void 0 ? void 0 : cssInline.includes(curr)) ? [...pre.cssInjectOrder, curr] : pre.cssInjectOrder
    }), { cssInlineOrder: [], cssInjectOrder: [] });
    const inlineCssContent = (await Promise.all(cssInlineOrder.map(css => manifest[css]).filter(Boolean).map(css => promises.readFile(isAbsolute(css) ? css : join(cwd, './build', css))))).map(item => item.toString());
    return [
        inlineCssContent,
        cssInjectOrder
    ];
};
//# sourceMappingURL=runtime.js.map