"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServerWebpack = void 0;
const path_1 = require("path");
const ssr_common_utils_1 = require("ssr-common-utils");
const webpack = require("ssr-webpack4");
const base_1 = require("./base");
const getServerWebpack = (chain) => {
    const config = (0, ssr_common_utils_1.loadConfig)();
    const { isDev, cwd, getOutput, chainServerConfig, whiteList, chunkName } = config;
    (0, base_1.getBaseConfig)(chain, true);
    chain.target('node');
    chain.entry(chunkName)
        .add(require.resolve('../entry/server-entry'))
        .end()
        .output
        .path(getOutput().serverOutPut)
        .filename('[name].server.js')
        .libraryTarget('commonjs')
        .end();
    const modulesDir = [(0, path_1.join)(cwd, './node_modules')];
    chain.optimization
        .minimizer('terser')
        .use((0, ssr_common_utils_1.loadModuleFromFramework)('terser-webpack-plugin'), [(0, ssr_common_utils_1.terserConfig)()]);
    chain.externals((0, ssr_common_utils_1.nodeExternals)({
        whitelist: whiteList,
        // externals Dir contains example/xxx/node_modules ssr/node_modules
        modulesDir
    }));
    chain.when(isDev, () => {
        chain.watch(true);
    });
    chain.plugin('serverLimit').use(webpack.optimize.LimitChunkCountPlugin, [{
            maxChunks: 1
        }]);
    chainServerConfig(chain); // 合并用户自定义配置
    return chain.toConfig();
};
exports.getServerWebpack = getServerWebpack;
//# sourceMappingURL=server.js.map